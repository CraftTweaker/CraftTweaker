/*
 * This file is subject to the license.txt file in the main folder
 * of this project.
 */

package stanhebben.zenscript.parser;

import static java.util.Arrays.sort;

/**
 * Represents a compiled DFA. A compiled DFA has a compact representation and is
 * immediately usable for efficient processing.
 *
 * A compiled DFA can be converted to a compact integer array. This array can
 * then be hardcoded in an application.
 *
 * @author Stan Hebben
 */
public class CompiledDFA {
	public static final int NOFINAL = Integer.MIN_VALUE;

	public HashMapII[] transitions;
	public int[] finals;

	/**
	 * Constructs a compiled DFA from the specified transition graph and finals
	 * arrays.
	 *
	 * The transition array specifies all transitions for each state. The finals
	 * array specifies the final class index of each state, or NOFINAL if the
	 * state is not a final. There can multiple final classes, which can, for
	 * example, be used to distinguish token types.
	 *
	 * @param transitions transitions graph
	 * @param finals finals
	 */
	public CompiledDFA(HashMapII[] transitions, int[] finals) {
		this.transitions = transitions;
		this.finals = finals;
	}

	/**
	 * Converts an integer array with a DFA definition (generated by toArray())
	 * to a CompiledDFA.
	 *
	 * @param definition definition array
	 */
	public CompiledDFA(int[] definition) {
		int ix = 0;
		int numStates = definition[ix++];
		transitions = new HashMapII[numStates];
		finals = new int[numStates];

		for (int i = 0; i < numStates; i++) {
			transitions[i] = new HashMapII();
			finals[i] = definition[ix++];

			int numRanges = definition[ix++];
			for (int j = 0; j < numRanges; j++) {
				int from = definition[ix++];
				int to = definition[ix++];
				int state = definition[ix++];
				for (int k = from; k <= to; k++) {
					transitions[i].put(k, state);
				}
			}

			int numSingles = definition[ix++];
			for (int j = 0; j < numSingles; j++) {
				int label = definition[ix++];
				int state = definition[ix++];
				transitions[i].put(label, state);
			}
		}
	}

	/**
	 * Converts the DFA to an integer array.
	 *
	 * @return an integer array representation of the DFA
	 */
	public int[] toArray() {
		ArrayListI result = new ArrayListI();
		result.add(finals.length);

		for (int i = 0; i < finals.length; i++) {
			result.add(finals[i]);

			ArrayListI singles = new ArrayListI();
			ArrayListI rangeFrom = new ArrayListI();
			ArrayListI rangeTo = new ArrayListI();

			int[] keys = transitions[i].keysArray();
			sort(keys);
			for (int j = 0; j < keys.length; j++) {
				int from = j;
				int state = transitions[i].get(j);
				while (j + 1 < keys.length && keys[j + 1] == keys[j] + 1 && transitions[i].get(j + 1) == state)
					j++;
				if (j == from) {
					singles.add(keys[j]);
				} else {
					rangeFrom.add(keys[from]);
					rangeTo.add(keys[j]);
				}
			}

			result.add(rangeFrom.size());
			for (int j = 0; j < rangeFrom.size(); j++) {
				result.add(rangeFrom.get(j));
				result.add(rangeTo.get(j));
				result.add(transitions[i].get(rangeFrom.get(j)));
			}
			result.add(singles.size());
			for (int j = 0; j < singles.size(); j++) {
				result.add(singles.get(j));
				result.add(transitions[i].get(singles.get(j)));
			}
		}
		return result.toArray();
	}

	/* Used for debugging */
	@Override
	public String toString() {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < transitions.length; i++) {
			HashMapII map = transitions[i];

			IteratorI it = map.keys();
			while (it.hasNext()) {
				int v = it.next();
				result.append("edge(");
				result.append(i);
				result.append(", ");
				result.append(v);
				result.append("): ");
				result.append(map.get(v));
				result.append("\r\n");
			}
		}
		for (int i = 0; i < finals.length; i++) {
			if (finals[i] != DFA.NOFINAL) {
				result.append("final(");
				result.append(i);
				result.append("): ");
				result.append(finals[i]);
				result.append("\r\n");
			}
		}
		return result.toString();
	}
}
